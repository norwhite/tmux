/*
Copyright (c) 2017 Jens Stimpfle

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

/*
 * WARNING: This file is autogenerated.
 */

#ifndef RB3_HEADER
#define RB3_HEADER
/* don't want no assert.h dependency */
#define RB3_ASSERT(cond)   /* TODO */

/* don't want no stddef.h dependency */
#define RB3_NULL ((void *)0)
#define RB3_offsetof(st, m) ((char *)&(((st *)0)->m)-((char *)0))

#define RB3_COLD __attribute__((cold))
#define RB3_INLINE inline __attribute__((always_inline))
#define RB3_NEVERINLINE __attribute__((noinline))

#define RB3_API extern
#define RB3_API_INLINE static inline __attribute__((unused))
#define RB3_API_STATIC_INLINE static inline  __attribute__((unused))

/*
 * This type is used to efficiently store a pointer (at least 4-byte aligned)
 * and some more information in the unused low bits.
 */
typedef unsigned long rb3_ptr;

/*
 * Directions for navigation in the tree.
 */
enum {
        RB3_LEFT = 0,
        RB3_RIGHT = 1,
};

/*
 * Node type for 3-pointer Red-black trees.
 */
struct rb3_head {
        /*
         * Left, right, and parent pointers.
         *
         * The left and right pointers have additional color bits.
         *
         * The parent pointer contains a direction bit indicating the direction
         * to this child.
         */
        rb3_ptr child[2];
        rb3_ptr parent;
};

/*
 * Tree type. It's just a fake base head that is wrapped for type safety and
 * future extensibility.
 */
struct rb3_tree {
        struct rb3_head base;
};

/*
 * User-provided comparison function. It must first cast (and offset) the
 * pointers to compare the client-side structures that embed `a` and `b`.
 *
 * If a < b, returns some value < 0.
 * If a > b, returns some value > 0.
 * If a == b, returns 0.
 *
 * This function type is used by the implementation for deciding which child
 * direction to take to find insertion or deletion points in a tree.
 *
 * In some cases, non-strictly monotonic comparison functions (with regards to
 * the ordering of the nodes in a tree) make sense. An example is
 * rb3_find_first() which needs only a monotonic "predicate" to return the
 * first node in the tree that "compares" equal (i.e. where the "predicate"
 * returns 0).
 */
typedef int (*rb3_cmp)(struct rb3_head *a, struct rb3_head *b);

/*
 * User-provided search function. This is a more general variant of rb3_cmp
 * that supports more specialized searches in a tree.
 *
 * If head_in_tree is "smaller" than data, returns some value < 0.
 * If head_in_tree is "greater" than data, returns some value > 0.
 * If head_in_tree is "equal" to data, returns 0.
 *
 * As stated above this is a generalization of rb3_cmp. Conversely, rb3_cmp is
 * a specialization of rb3_pred that expects another struct rb3_head pointer
 * as `data` argument.
 *
 * This function type is required for some complex applications where
 * additional context is needed to make decisions. For example, in Fortune's
 * algorithm, the order of any two given intersection points is parameterized
 * by the moving beachlines. (The client code must make sure that nodes are
 * deleted from the tree before their ordering with respect to other elements
 * in the tree changes (rendering the tree invalid)).
 *
 * Another use case of rb3_datacmp is looking for nodes in a tree without any
 * reference node at all. An obvious example is searching the first node in a
 * tree of 2D coordinates that has x-value greater than a given reference
 * value.
 */
typedef int (*rb3_datacmp)(struct rb3_head *head_in_tree, void *data);

/*
 * Get direction from parent to child by testing the direction
 *
 * Return RB3_LEFT or RB3_RIGHT, depending on whether this node is the left or
 * right child of its parent node. If the given node is the root node,
 * RB3_LEFT is returned. (Technically the root node is the left child of the
 * base node).
 *
 * This is more convenient and (in theory) more efficient than getting the
 * parent and testing its left and right child.
 */
RB3_API_INLINE
int rb3_get_parent_dir(struct rb3_head *head);

/*
 * Get parent head, or NULL if given node is the base node.
 *
 * Note that normally you don't want to visit the base node but stop already
 * at the root node.
 *
 * Time complexity: O(1)
 */
RB3_API_INLINE
struct rb3_head *rb3_get_parent(struct rb3_head *head);

/*
 * Test if a (left or right) child exists
 *
 * This is slightly more efficient than calling rb3_get_child() and comparing
 * to NULL.
 *
 * Time complexity: O(1)
 */
RB3_API_INLINE
int rb3_has_child(struct rb3_head *head, int dir);

/*
 * Get child in given direction, or NULL if there is no such child. `dir`
 * must be RB3_LEFT or RB3_RIGHT.
 *
 * Time complexity: O(1)
 */
RB3_API_INLINE
struct rb3_head *rb3_get_child(struct rb3_head *head, int dir);

/*
 * Get fake base of tree.
 *
 * Warning: the special base element is never embedded in a client payload
 * structure. It's just a link to host the real root of the tree as its left
 * child.
 */
RB3_API_INLINE
struct rb3_head *rb3_get_base(struct rb3_tree *tree);

/*
 * ---------------------------------------------------------------------------
 * Inline implementations
 * ---------------------------------------------------------------------------
 */

RB3_API_INLINE
int rb3_get_parent_dir(struct rb3_head *head)
{
        return head->parent & 1;
}

RB3_API_INLINE
struct rb3_head *rb3_get_parent(struct rb3_head *head)
{
        return (struct rb3_head *)(head->parent & ~3);
}

RB3_API_INLINE
int rb3_has_child(struct rb3_head *head, int dir)
{
        return head->child[dir] != 0;
}

RB3_API_INLINE
struct rb3_head *rb3_get_child(struct rb3_head *head, int dir)
{
        return (struct rb3_head *)((head->child[dir]) & ~3);
}

RB3_API_INLINE
struct rb3_head *rb3_get_base(struct rb3_tree *tree)
{
        return &tree->base;
}

/*
 * ---------------------------------------------------------------------------
 * BASIC API
 *
 * These functions provide basic usability as an abstract ordered container.
 * Often they are all you need to know.
 * ---------------------------------------------------------------------------
 */

/*
 * Initialize an rb3_tree.
 *
 * Time complexity: O(1)
 */
RB3_API
void rb3_init(struct rb3_tree *tree);

/*
 * Free resources allocated by an rb3_tree (currently none, but this could
 * change).
 */
RB3_API
void rb3_exit(struct rb3_tree *tree);

/*
 * Check if tree is empty.
 *
 * Time complexity: O(1)
 */
RB3_API_INLINE
int rb3_isempty(struct rb3_tree *tree);

/*
 * Get minimum (lefmost) element, or NULL if tree is empty.
 *
 * Time complexity: O(log n)
 */
RB3_API
struct rb3_head *rb3_get_min(struct rb3_tree *tree);

/*
 * Get maximum (rightmost) element, or NULL if tree is empty
 *
 * Time complexity: O(log n)
 */
RB3_API
struct rb3_head *rb3_get_max(struct rb3_tree *tree);

/*
 * Get previous in-order node (maximal node in the tree that sorts before the
 * given element) or NULL if no such element is in the tree.
 *
 * Time complexity: O(log n), amortized over sequential scan: O(1)
 */
RB3_API
struct rb3_head *rb3_get_prev(struct rb3_head *head);

/*
 * Get next in-order node (minimal node in the tree that sorts after the given
 * element) or NULL if no such element is in the tree.
 *
 * Time complexity: O(log n), amortized over sequential scan: O(1)
 */
RB3_API
struct rb3_head *rb3_get_next(struct rb3_head *head);

/*
 * Insert `head` into `tree` using `cmp` to direct the search. At each visited
 * node in the tree `cmp` is called with that node and `head` as arguments (in
 * that order). If a node that compares equal is found, it is returned.
 * Otherwise, `head` is inserted into the tree and NULL is returned.
 *
 * Time complexity: O(log n)
 */
RB3_API
struct rb3_head *rb3_insert(struct rb3_head *head, struct rb3_tree *tree, rb3_cmp cmp);

/*
 * Find `head` in `tree` using `cmp` to direct the search. At each visited
 * node in the tree `cmp` is called with that node and `head` as arguments (in
 * that order). If a node that compares equal is found, it is returned.
 * Otherwise, NULL is returned.
 *
 * Time complexity: O(log n)
 */
RB3_API
struct rb3_head *rb3_find(struct rb3_tree *tree, rb3_cmp cmp, struct rb3_head *head);

/*
 * Delete `head` from `tree` using `cmp` to direct the search. At each visited
 * node in the tree `cmp` is called with that node and `head` as arguments (in
 * that order). If a node that compares equal is found, it is unlinked from
 * the tree and returned. Otherwise, NULL is returned.
 *
 * Time complexity: O(log n)
 */
RB3_API
struct rb3_head *rb3_delete(struct rb3_tree *tree, rb3_cmp cmp, struct rb3_head *head);

/*
 * Like rb3_insert() but use a rb3_datacmp comparison function and `data` to
 * direct the search. Note in particular that `head` is not used during the
 * search phase.
 */
RB3_API
struct rb3_head *rb3_insert_datacmp(struct rb3_head *head, struct rb3_tree *tree, rb3_datacmp datacmp, void *data);

/*
 * Like rb3_find() but use a rb3_datacmp comparison function and `data` to
 * direct the search.
 */
RB3_API
struct rb3_head *rb3_find_datacmp(struct rb3_tree *tree, rb3_datacmp cmp, void *data);

/*
 * Like rb3_delete() but use a rb3_datacmp comparison function and `data` to
 * direct the search.
 */
RB3_API
struct rb3_head *rb3_delete_datacmp(struct rb3_tree *tree, rb3_datacmp cmp, void *data);

/*
 * Inline implementations
 */

RB3_API_INLINE
int rb3_isempty(struct rb3_tree *tree)
{
        return !rb3_has_child(rb3_get_base(tree), RB3_LEFT);
}

/*
 * ---------------------------------------------------------------------------
 * Navigational API
 *
 * These functions provide advanced functionality for navigation in a
 * binary search tree.
 * ---------------------------------------------------------------------------
 */

/*
 * Get topmost element of tree (or NULL if empty)
 *
 * Time complexity: O(1)
 */
RB3_API_INLINE
struct rb3_head *rb3_get_root(struct rb3_tree *tree);

/*
 * Get previous in-order ancestor (maximal ancestor node that sorts before the
 * given element) or NULL if no such element is in the tree.
 *
 * Time complexity: O(log n)
 */
RB3_API
struct rb3_head *rb3_get_prev_ancestor(struct rb3_head *head);

/*
 * Get next in-order ancestor (minimal ancestor node that sorts after the
 * given element) or NULL if no such element is in the tree.
 *
 * Time complexity: O(log n)
 */
RB3_API
struct rb3_head *rb3_get_next_ancestor(struct rb3_head *head);

/*
 * Get previous in-order descendant (maximal descendant node that sorts before
 * the given element) or NULL if no such element is in the tree.
 *
 * Time complexity: O(log n)
 */
RB3_API
struct rb3_head *rb3_get_prev_descendant(struct rb3_head *head);

/*
 * Get next in-order descendant (minimal descendant node that sorts after the
 * given element) or NULL if no such element is in the tree.
 *
 * Time complexity: O(log n)
 */
RB3_API
struct rb3_head *rb3_get_next_descendant(struct rb3_head *head);

/*
 * Inline implementations
 */

RB3_API_INLINE
struct rb3_head *rb3_get_root(struct rb3_tree *tree)
{
        return rb3_get_child(&tree->base, RB3_LEFT);
}

/*
 * ---------------------------------------------------------------------------
 * INTERNAL API
 *
 * These functions expose some of the more stable implementation details that
 * might be useful in other places. They are generally unsafe to use. Make
 * sure to read the assumptions that must hold before calling them.
 * ---------------------------------------------------------------------------
 */

/*
 * Like rb3_find_datacmp() but starts at the given subtree represented by a
 * link head (which may be NULL) instead of at the root of the tree.
 */
struct rb3_head *rb3_find_in_subtree_datacmp(struct rb3_head *subtree, rb3_datacmp cmp, void *data);

/*
 * Find suitable insertion point for a new node in a subtree, directed by the
 * rb3_datacmp search. The subtree is given by its parent node `parent` and
 * child direction `dir`. The insertion point and its child direction are
 * returned in `parent_out` and `dir_out`.
 *
 * If the searched node is already in the tree (the compare function returns
 * 0), it is returned. In this case `parent_out` and `dir_out` are left
 * untouched.
 */
struct rb3_head *rb3_find_parent_in_subtree_datacmp(struct rb3_head *parent, int dir, rb3_datacmp cmp, void *data, struct rb3_head **parent_out, int *dir_out);

/*
 * Insert a node below another node in the given direction (RB3_LEFT or
 * RB3_RIGHT). The new node must replace a leaf. You can use rb3_find_parent()
 * to find the insertion point.
 *
 * Time complexity: O(log n)
 */
RB3_API
void rb3_insert_below(struct rb3_head *head, struct rb3_head *parent, int dir);

/*
 * Delete a node that is known to be linked in a tree.
 *
 * This is more efficient than using rb3_find() because no search is needed.
 * On the downside, the user must guarantee that the node really is linked in
 * some tree.
 *
 * Time complexity: O(log n)
 */
RB3_API
void rb3_delete_head(struct rb3_head *head);

/*
 * Given a node that is known to be linked in _some_ tree, find that tree.
 */
RB3_API
struct rb3_tree *rb3_get_containing_tree(struct rb3_head *head);

/*
 * Inline implementations
 */


/* this interface is meant for code generation, not for casual consumption */
RB3_API_STATIC_INLINE
struct rb3_head *rb3_INLINE_find_in_subtree(struct rb3_head *subtree, rb3_datacmp cmp, void *data)
{
        struct rb3_head *head;
        int dir;
        int r;

        head = subtree;
        while (head) {
                r = cmp(head, data);
                if (r < 0)
                        dir = RB3_RIGHT;
                else if (r > 0)
                        dir = RB3_LEFT;
                else
                        return head;
                head = rb3_get_child(head, dir);
        }
        return RB3_NULL;
}

/* this interface is meant for code generation, not for casual consumption */
RB3_API_STATIC_INLINE
struct rb3_head *rb3_INLINE_find_parent_in_subtree(struct rb3_head *parent, int dir, rb3_datacmp cmp, void *data, struct rb3_head **parent_out, int *dir_out)
{
        struct rb3_head *head;
        int r;

        RB3_ASSERT(parent != RB3_NULL);
        do {
                head = rb3_get_child(parent, dir);
                if (!head)
                        break;
                r = cmp(head, data);
                if (r < 0)
                        dir = RB3_RIGHT;
                else if (r > 0)
                        dir = RB3_LEFT;
                else
                        break;
                parent = head;
        } while (head);
        *parent_out = parent;
        *dir_out = dir;
        return RB3_NULL;
}

#endif /* !defined(RB3_HEADER) */
